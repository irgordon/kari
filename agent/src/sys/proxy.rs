use async_trait::async_trait;
use tokio::fs;
use tokio::process::Command;
use std::path::{Path, PathBuf};

#[async_trait]
pub trait ProxyManager: Send + Sync {
    async fn create_vhost(&self, domain: &str, target_port: u16) -> Result<(), String>;
    async fn remove_vhost(&self, domain: &str) -> Result<(), String>;
}

pub struct ApacheManager {
    sites_available: PathBuf,
    sites_enabled: PathBuf,
}

impl ApacheManager {
    pub fn new(base_path: PathBuf) -> Self {
        Self {
            sites_available: base_path.join("sites-available"),
            sites_enabled: base_path.join("sites-enabled"),
        }
    }

    /// üõ°Ô∏è Zero-Trust: Validate domain to prevent path traversal
    fn get_safe_paths(&self, domain: &str) -> Result<(PathBuf, PathBuf), String> {
        if domain.contains('/') || domain.contains("..") || domain.is_empty() {
            return Err("SECURITY VIOLATION: Malformed domain name".into());
        }
        
        let config_path = self.sites_available.join(format!("{}.conf", domain));
        let enabled_link = self.sites_enabled.join(format!("{}.conf", domain));
        
        Ok((config_path, enabled_link))
    }

    async fn test_and_reload(&self) -> Result<(), String> {
        // üõ°Ô∏è SLA: Strict config validation before touching the live service
        let check = Command::new("apache2ctl")
            .arg("configtest")
            .output()
            .await
            .map_err(|e| format!("Apache check failed: {}", e))?;

        if !check.status.success() {
            let stderr = String::from_utf8_lossy(&check.stderr);
            return Err(format!("Apache configuration error: {}", stderr));
        }

        Command::new("systemctl")
            .args(["reload", "apache2"])
            .output()
            .await
            .map_err(|e| format!("Systemd reload failed: {}", e))?;

        Ok(())
    }
}

#[async_trait]
impl ProxyManager for ApacheManager {
    async fn create_vhost(&self, domain: &str, target_port: u16) -> Result<(), String> {
        let (config_path, enabled_link) = self.get_safe_paths(domain)?;

        // üõ°Ô∏è Zero-Trust: Hardened VHost Template with Modern Security Headers
        let content = format!(
            r#"# Generated by Karƒ± Orchestration - DO NOT EDIT MANUALLY
<VirtualHost *:80>
    ServerName {domain}

    ProxyPreserveHost On
    ProxyPass / http://127.0.0.1:{target_port}/
    ProxyPassReverse / http://127.0.0.1:{target_port}/

    # --- üõ°Ô∏è Hardened Security Headers ---
    Header always set X-Content-Type-Options "nosniff"
    Header always set X-Frame-Options "SAMEORIGIN"
    Header always set X-XSS-Protection "1; mode=block"
    Header always set Referrer-Policy "strict-origin-when-cross-origin"
    
    ErrorLog ${{APACHE_LOG_DIR}}/{domain}_error.log
    CustomLog ${{APACHE_LOG_DIR}}/{domain}_access.log combined
</VirtualHost>"#,
            domain = domain,
            target_port = target_port
        );

        // üõ°Ô∏è SLA: Atomic Write-and-Enable
        fs::write(&config_path, content).await.map_err(|e| e.to_string())?;

        if !enabled_link.exists() {
            // Using symbolic links is standard for Debian/Ubuntu Apache
            fs::symlink(&config_path, &enabled_link).await.map_err(|e| e.to_string())?;
        }

        // Attempt reload. If it fails, we MUST remove the link to keep Apache healthy.
        if let Err(e) = self.test_and_reload().await {
            let _ = fs::remove_file(&enabled_link).await;
            return Err(format!("Rollback triggered: {}", e));
        }

        Ok(())
    }

    async fn remove_vhost(&self, domain: &str) -> Result<(), String> {
        let (config_path, enabled_link) = self.get_safe_paths(domain)?;

        // Cleanup both locations
        let _ = fs::remove_file(enabled_link).await;
        let _ = fs::remove_file(config_path).await;

        self.test_and_reload().await
    }
}
