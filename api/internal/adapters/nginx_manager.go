// api/internal/adapters/nginx_manager.go
package adapters

import (
	"bytes"
	"context"
	"fmt"
	"log/slog"
	"regexp"
	"text/template"

	"kari/api/internal/config"
	"kari/api/internal/core/domain"
	pb "kari/api/proto/kari/agent/v1" // Aliased for clarity
)

// ==============================================================================
// 1. Adapter Struct & Dependency Injection
// ==============================================================================

type NginxManager struct {
	Config      *config.Config
	AgentClient pb.SystemAgentClient
	Logger      *slog.Logger
	Template    *template.Template
}

// Strictly enforce valid domain names (e.g., sub.example.com)
var domainRegex = regexp.MustCompile(`^[a-zA-Z0-9][a-zA-Z0-9.-]{1,253}[a-zA-Z0-9]$`)

func NewNginxManager(cfg *config.Config, agentClient pb.SystemAgentClient, logger *slog.Logger) *NginxManager {
	tmpl := template.Must(template.New("nginx_vhost").Parse(nginxTemplate))
	return &NginxManager{
		Config:      cfg,
		AgentClient: agentClient,
		Logger:      logger,
		Template:    tmpl,
	}
}

// ==============================================================================
// 2. Concrete Implementation of the WebServerManager SLA
// ==============================================================================

func (m *NginxManager) ApplyConfig(ctx context.Context, appConfig domain.WebServerConfig) error {
	// üõ°Ô∏è 1. Zero-Trust Validation (Anti-Injection & Anti-Traversal)
	if !domainRegex.MatchString(appConfig.DomainName) {
		return fmt.Errorf("SECURITY VIOLATION: Invalid domain name format")
	}

	m.Logger.Info("Generating Nginx configuration", slog.String("domain", appConfig.DomainName))

	// 2. Compile the Template
	data := struct {
		DomainName string
		Port       int
		HasSSL     bool
		SSLDir     string
		WebRoot    string // üõ°Ô∏è Dynamically injected
	}{
		DomainName: appConfig.DomainName,
		Port:       appConfig.LocalPort,
		HasSSL:     appConfig.HasSSL,
		SSLDir:     m.Config.SSLStorageDir,
		WebRoot:    m.Config.WebRoot,
	}

	var buf bytes.Buffer
	if err := m.Template.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute Nginx template: %w", err)
	}

	configPath := fmt.Sprintf("%s/%s.conf", m.Config.NginxConfPath, appConfig.DomainName)
	
	writeReq := &pb.FileWriteRequest{
		TraceId:      fmt.Sprintf("nginx-%s", appConfig.DomainName),
		AbsolutePath: configPath,
		Content:      buf.Bytes(),
		Owner:        "root",
		Group:        "root",
		FileMode:     "0644",
	}

	if _, err := m.AgentClient.WriteSystemFile(ctx, writeReq); err != nil {
		return fmt.Errorf("agent failed to write Nginx config: %w", err)
	}

	// Command the Rust Agent to reload the Nginx Daemon
	reloadReq := &pb.ServiceRequest{
		ServiceName: "nginx",
		Action:      pb.ServiceAction_RELOAD,
	}

	if _, err := m.AgentClient.ManageService(ctx, reloadReq); err != nil {
		return fmt.Errorf("agent failed to reload Nginx: %w", err)
	}

	m.Logger.Info("‚úÖ Nginx configuration successfully applied", slog.String("domain", appConfig.DomainName))
	return nil
}

func (m *NginxManager) RemoveConfig(ctx context.Context, domainName string) error {
	// üõ°Ô∏è Zero-Trust Validation
	if !domainRegex.MatchString(domainName) {
		return fmt.Errorf("SECURITY VIOLATION: Invalid domain name format")
	}

	configPath := fmt.Sprintf("%s/%s.conf", m.Config.NginxConfPath, domainName)
	
	removeReq := &pb.PackageRequest{
		Command: "rm",
		Args:    []string{"-f", configPath},
	}

	if _, err := m.AgentClient.ExecutePackageCommand(ctx, removeReq); err != nil {
		return fmt.Errorf("agent failed to remove Nginx config: %w", err)
	}

	reloadReq := &pb.ServiceRequest{
		ServiceName: "nginx",
		Action:      pb.ServiceAction_RELOAD,
	}
	_, err := m.AgentClient.ManageService(ctx, reloadReq)
	
	return err
}

// ==============================================================================
// 3. The Nginx Configuration Template
// ==============================================================================

const nginxTemplate = `
# Automatically generated by Kari. DO NOT EDIT MANUALLY.
# Domain: {{.DomainName}}

{{if .HasSSL}}
# HTTP -> HTTPS Redirect
server {
    listen 80;
    listen [::]:80;
    server_name {{.DomainName}};
    
    location /.well-known/acme-challenge/ {
        # üõ°Ô∏è Platform Agnostic WebRoot
        root {{.WebRoot}};
        allow all;
    }

    location / {
        return 301 https://$host$request_uri;
    }
}

# HTTPS Server Block
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name {{.DomainName}};

    ssl_certificate {{.SSLDir}}/{{.DomainName}}/fullchain.pem;
    ssl_certificate_key {{.SSLDir}}/{{.DomainName}}/privkey.pem;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
{{else}}
# HTTP-Only Server Block (Awaiting SSL Provisioning)
server {
    listen 80;
    listen [::]:80;
    server_name {{.DomainName}};

    location /.well-known/acme-challenge/ {
        # üõ°Ô∏è Platform Agnostic WebRoot
        root {{.WebRoot}};
        allow all;
    }
{{end}}

    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Reverse Proxy to Kari systemd local port
    location / {
        proxy_pass http://127.0.0.1:{{.Port}};
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}
`
